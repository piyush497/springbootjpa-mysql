name: Deploy Java App to Kind Kubernetes

on:
  
  workflow_dispatch: # Allows manual trigger

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Set up Kind Cluster
      uses: helm/kind-action@v1.9.0 # Use a recent version
      with:
        node_image: kindest/node:v1.28.0 # Specify Kubernetes version

    #- name: Build and Push Docker Image (if not already on Docker Hub)
      # This step assumes your Java app has a Dockerfile in your repo
      # If your image is already on Docker Hub, you can skip this.
    #  run: |
    #    docker build -t your-dockerhub-username/your-java-app:latest .
    #    docker push your-dockerhub-username/your-java-app:latest

    - name: Create Kubernetes Manifests (example, you'll have your own)
      # This is a placeholder. You should have your actual deployment.yaml and service.yaml
      run: |
        cat <<EOF > deployment.yaml
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: springbootjpa-app-deployment
          labels:
            app: java-app
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: java-app
          template:
            metadata:
              labels:
                app: java-app
            spec:
              containers:
              - name: java-app
                image: piyush497/springbootjpa-mysql:latest
                ports:
                - containerPort: 8086 # Assuming your Java app runs on port 8080
        EOF

        cat <<EOF > service.yaml
        apiVersion: v1
        kind: Service
        metadata:
          name: springbootjpa-app-service
        spec:
          selector:
            app: java-app
          ports:
            - protocol: TCP
              port: 80
              targetPort: 8086
          type: NodePort # Or LoadBalancer if you had an external LB
        EOF

    - name: Deploy to Kind Cluster
      run: |
        kubectl apply -f deployment.yaml
        kubectl apply -f service.yaml

    - name: Verify Deployment
      run: |
        kubectl get pods
        kubectl get deployments
        kubectl get services
        kubectl rollout status deployment/springbootjpa-app-deployment
        # You might add a curl command here if your service is accessible within the cluster
        # e.g., kubectl exec -it $(kubectl get pod -l app=java-app -o jsonpath='{.items[0].metadata.name}') -- curl localhost:8080

    - name: Clean up (optional, Kind will be torn down automatically)
      run: |
        kubectl delete -f deployment.yaml
        kubectl delete -f service.yaml